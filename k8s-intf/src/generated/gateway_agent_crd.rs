// SPDX-License-Identifier: Apache-2.0
// Copyright Open Network Fabric Authors

use k8s_sample_derive::Sample;
use crate::samplegen::sample::Sample;
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -D PartialEq -D Sample -Af -
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// GatewayAgentSpec defines the desired state of GatewayAgent.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
#[kube(group = "gwint.githedgehog.com", version = "v1alpha1", kind = "GatewayAgent", plural = "gatewayagents")]
#[kube(namespaced)]
#[kube(status = "GatewayAgentStatus")]
#[kube(derive="PartialEq")]
#[kube(derive="Sample")]
pub struct GatewayAgentSpec {
    /// AgentVersion is the desired version of the gateway agent to trigger generation changes on controller upgrades
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentVersion")]
    pub agent_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub communities: Option<BTreeMap<String, String>>,
    /// GatewaySpec defines the desired state of Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<GatewayAgentGateway>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<BTreeMap<String, GatewayAgentGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peerings: Option<BTreeMap<String, GatewayAgentPeerings>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpcs: Option<BTreeMap<String, GatewayAgentVpcs>>,
}

/// GatewaySpec defines the desired state of Gateway.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGateway {
    /// ASN is the ASN of the gateway
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<u32>,
    /// Groups is a list of group memberships for the gateway
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<GatewayAgentGatewayGroups>>,
    /// Interfaces is a map of interface names to their configurations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<BTreeMap<String, GatewayAgentGatewayInterfaces>>,
    /// Logs defines the configuration for logging levels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logs: Option<GatewayAgentGatewayLogs>,
    /// Neighbors is a list of BGP neighbors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub neighbors: Option<Vec<GatewayAgentGatewayNeighbors>>,
    /// Profiling defines the configuration for profiling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profiling: Option<GatewayAgentGatewayProfiling>,
    /// ProtocolIP is used as a loopback IP and BGP Router ID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolIP")]
    pub protocol_ip: Option<String>,
    /// VTEP IP to be used by the gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepIP")]
    pub vtep_ip: Option<String>,
    /// VTEP MAC address to be used by the gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepMAC")]
    pub vtep_mac: Option<String>,
    /// VTEPMTU is the MTU for the VTEP interface
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepMTU")]
    pub vtep_mtu: Option<u32>,
    /// Workers defines the number of worker threads to use for dataplane
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<u8>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGatewayGroups {
    /// Name is the name of the group to which the gateway belongs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Priority is the priority of the gateway within the group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<u32>,
}

/// Interfaces is a map of interface names to their configurations
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGatewayInterfaces {
    /// IPs is the list of IP address to assign to the interface
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ips: Option<Vec<String>>,
    /// Kernel is the kernel name of the interface to use (required for kernel driver), e.g. enp2s1
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kernel: Option<String>,
    /// MTU for the interface
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mtu: Option<u32>,
    /// PCI address of the interface (required for DPDK driver), e.g. 0000:00:01.0
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pci: Option<String>,
}

/// Logs defines the configuration for logging levels
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGatewayLogs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
}

/// GatewayBGPNeighbor defines the configuration for a BGP neighbor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGatewayNeighbors {
    /// ASN is the remote ASN of the BGP neighbor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<u32>,
    /// IP is the IP address of the BGP neighbor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    /// Source is the source interface for the BGP neighbor configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Profiling defines the configuration for profiling
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGatewayProfiling {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<GatewayAgentGroupsMembers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentGroupsMembers {
    pub name: String,
    pub priority: u32,
    #[serde(rename = "vtepIP")]
    pub vtep_ip: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeerings {
    /// GatewayGroup is the name of the gateway group that should process the peering
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayGroup")]
    pub gateway_group: Option<String>,
    /// Peerings is a map of peering entries for each VPC participating in the peering (keyed by VPC name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peering: Option<BTreeMap<String, GatewayAgentPeeringsPeering>>,
}

/// Peerings is a map of peering entries for each VPC participating in the peering (keyed by VPC name)
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeering {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expose: Option<Vec<GatewayAgentPeeringsPeeringExpose>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExpose {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "as")]
    pub r#as: Option<Vec<GatewayAgentPeeringsPeeringExposeAs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ips: Option<Vec<GatewayAgentPeeringsPeeringExposeIps>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nat: Option<GatewayAgentPeeringsPeeringExposeNat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeAs {
    /// CIDR to include, only one of cidr, not can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDR to exclude, only one of cidr, not can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<String>,
    /// Port ranges (e.g. "80, 443, 3000-3100"), used together with exactly one of cidr, not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeIps {
    /// CIDR to include, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDR to exclude, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<String>,
    /// Port ranges (e.g. "80, 443, 3000-3100"), used together with exactly one of cidr, not, vpcSubnet
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<String>,
    /// CIDR by VPC subnet name to include, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSubnet")]
    pub vpc_subnet: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNat {
    /// Use connection state tracking when performing NAT
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stateful: Option<GatewayAgentPeeringsPeeringExposeNatStateful>,
    /// Use connection state tracking when performing NAT, use stateful NAT if omitted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stateless: Option<GatewayAgentPeeringsPeeringExposeNatStateless>,
}

/// Use connection state tracking when performing NAT
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNatStateful {
    /// Time since the last packet after which flows are removed from the connection state table
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<std::time::Duration>,
}

/// Use connection state tracking when performing NAT, use stateful NAT if omitted
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNatStateless {
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentVpcs {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalID")]
    pub internal_id: Option<String>,
    /// Subnets is a map of all subnets in the VPC (incl. CIDRs, VNIs, etc) keyed by the subnet name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<BTreeMap<String, GatewayAgentVpcsSubnets>>,
    /// VNI is the VNI for the VPC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vni: Option<u32>,
}

/// Subnets is a map of all subnets in the VPC (incl. CIDRs, VNIs, etc) keyed by the subnet name
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentVpcsSubnets {
    /// CIDR is the subnet CIDR block, such as "10.0.0.0/24"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
}

/// GatewayAgentStatus defines the observed state of GatewayAgent.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatus {
    /// AgentVersion is the version of the gateway agent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentVersion")]
    pub agent_version: Option<String>,
    /// Generation of the last successful configuration application
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedGen")]
    pub last_applied_gen: Option<i64>,
    /// Time of the last successful configuration application
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedTime")]
    pub last_applied_time: Option<String>,
    /// Time of the last heartbeat from the agent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastHeartbeat")]
    pub last_heartbeat: Option<String>,
    /// State represents collected data from the dataplane API that includes FRR as well
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<GatewayAgentStatusState>,
}

/// State represents collected data from the dataplane API that includes FRR as well
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatusState {
    /// Dataplane is the status of the dataplane
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dataplane: Option<GatewayAgentStatusStateDataplane>,
    /// FRR is the status of the FRR daemon
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub frr: Option<GatewayAgentStatusStateFrr>,
    /// LastCollectedTime is the time of the last successful collection of data from the dataplane API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastCollectedTime")]
    pub last_collected_time: Option<String>,
    /// Peerings is the status of the VPCs peerings where key is VPC1->VPC2 and data is for one direction only
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peerings: Option<BTreeMap<String, GatewayAgentStatusStatePeerings>>,
    /// VPCs is the status of the VPCs where key is the vpc (vpcinfo) name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpcs: Option<BTreeMap<String, GatewayAgentStatusStateVpcs>>,
}

/// Dataplane is the status of the dataplane
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatusStateDataplane {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// FRR is the status of the FRR daemon
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatusStateFrr {
    /// LastAppliedGen is the generation of the last successful application of a configuration to the FRR
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedGen")]
    pub last_applied_gen: Option<i64>,
}

/// Peerings is the status of the VPCs peerings where key is VPC1->VPC2 and data is for one direction only
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatusStatePeerings {
    /// Bytes is the number of bytes sent on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub b: Option<u64>,
    /// BytesPerSecond is the number of bytes sent per second on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bps: Option<f64>,
    /// Drops is the number of packets dropped on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub d: Option<u64>,
    /// Packets is the number of packets sent on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub p: Option<u64>,
    /// PktsPerSecond is the number of packets sent per second on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pps: Option<f64>,
}

/// VPCs is the status of the VPCs where key is the vpc (vpcinfo) name
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Sample, JsonSchema)]
pub struct GatewayAgentStatusStateVpcs {
    /// Bytes is the number of bytes sent on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub b: Option<u64>,
    /// Drops is the number of packets dropped on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub d: Option<u64>,
    /// Packets is the number of packets sent on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub p: Option<u64>,
}

