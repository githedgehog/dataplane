// SPDX-License-Identifier: Apache-2.0
// Copyright Open Network Fabric Authors

pub const GW_API_VERSION: Option<&str> = Some("v0.38.0");

// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -D PartialEq -Af -
// kopium version: 0.22.5

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// GatewayAgentSpec defines the desired state of GatewayAgent.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[kube(group = "gwint.githedgehog.com", version = "v1alpha1", kind = "GatewayAgent", plural = "gatewayagents")]
#[kube(namespaced)]
#[kube(status = "GatewayAgentStatus")]
#[kube(derive="PartialEq")]
pub struct GatewayAgentSpec {
    /// AgentVersion is the desired version of the gateway agent to trigger generation changes on controller upgrades
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentVersion")]
    pub agent_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub communities: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<GatewayAgentConfig>,
    /// GatewaySpec defines the desired state of Gateway.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gateway: Option<GatewayAgentGateway>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<BTreeMap<String, GatewayAgentGroups>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peerings: Option<BTreeMap<String, GatewayAgentPeerings>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpcs: Option<BTreeMap<String, GatewayAgentVpcs>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentConfig {
    /// FabricBFD defines if fabric-facing links should be configured with BFD
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fabricBFD")]
    pub fabric_bfd: Option<bool>,
}

/// GatewaySpec defines the desired state of Gateway.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGateway {
    /// ASN is the ASN of the gateway
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<u32>,
    /// Groups is a list of group memberships for the gateway
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<GatewayAgentGatewayGroups>>,
    /// Interfaces is a map of interface names to their configurations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<BTreeMap<String, GatewayAgentGatewayInterfaces>>,
    /// Logs defines the configuration for logging levels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub logs: Option<GatewayAgentGatewayLogs>,
    /// Neighbors is a list of BGP neighbors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub neighbors: Option<Vec<GatewayAgentGatewayNeighbors>>,
    /// Profiling defines the configuration for profiling
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub profiling: Option<GatewayAgentGatewayProfiling>,
    /// ProtocolIP is used as a loopback IP and BGP Router ID
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolIP")]
    pub protocol_ip: Option<String>,
    /// VTEP IP to be used by the gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepIP")]
    pub vtep_ip: Option<String>,
    /// VTEP MAC address to be used by the gateway
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepMAC")]
    pub vtep_mac: Option<String>,
    /// VTEPMTU is the MTU for the VTEP interface
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vtepMTU")]
    pub vtep_mtu: Option<u32>,
    /// Workers defines the number of worker threads to use for dataplane
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<u8>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGatewayGroups {
    /// Name is the name of the group to which the gateway belongs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Priority is the priority of the gateway within the group
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priority: Option<u32>,
}

/// Interfaces is a map of interface names to their configurations
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGatewayInterfaces {
    /// IPs is the list of IP address to assign to the interface
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ips: Option<Vec<String>>,
    /// Kernel is the kernel name of the interface to use (required for kernel driver), e.g. enp2s1
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kernel: Option<String>,
    /// MTU for the interface
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mtu: Option<u32>,
    /// PCI address of the interface (required for DPDK driver), e.g. 0000:00:01.0
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pci: Option<String>,
}

/// Logs defines the configuration for logging levels
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGatewayLogs {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
}

/// GatewayBGPNeighbor defines the configuration for a BGP neighbor
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGatewayNeighbors {
    /// ASN is the remote ASN of the BGP neighbor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub asn: Option<u32>,
    /// IP is the IP address of the BGP neighbor
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ip: Option<String>,
    /// Source is the source interface for the BGP neighbor configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
}

/// Profiling defines the configuration for profiling
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGatewayProfiling {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGroups {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<GatewayAgentGroupsMembers>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentGroupsMembers {
    pub name: String,
    pub priority: u32,
    #[serde(rename = "vtepIP")]
    pub vtep_ip: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeerings {
    /// GatewayGroup is the name of the gateway group that should process the peering
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gatewayGroup")]
    pub gateway_group: Option<String>,
    /// Peerings is a map of peering entries for each VPC participating in the peering (keyed by VPC name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peering: Option<BTreeMap<String, GatewayAgentPeeringsPeering>>,
}

/// Peerings is a map of peering entries for each VPC participating in the peering (keyed by VPC name)
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeering {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expose: Option<Vec<GatewayAgentPeeringsPeeringExpose>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExpose {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "as")]
    pub r#as: Option<Vec<GatewayAgentPeeringsPeeringExposeAs>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ips: Option<Vec<GatewayAgentPeeringsPeeringExposeIps>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nat: Option<GatewayAgentPeeringsPeeringExposeNat>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeAs {
    /// CIDR to include, only one of cidr, not can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDR to exclude, only one of cidr, not can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<String>,
    /// Port ranges (e.g. "80, 443, 3000-3100"), used together with exactly one of cidr, not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeIps {
    /// CIDR to include, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
    /// CIDR to exclude, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub not: Option<String>,
    /// Port ranges (e.g. "80, 443, 3000-3100"), used together with exactly one of cidr, not, vpcSubnet
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ports: Option<String>,
    /// CIDR by VPC subnet name to include, only one of cidr, not, vpcSubnet can be set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "vpcSubnet")]
    pub vpc_subnet: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNat {
    /// Use connection state tracking when performing NAT
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stateful: Option<GatewayAgentPeeringsPeeringExposeNatStateful>,
    /// Use connection state tracking when performing NAT, use stateful NAT if omitted
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stateless: Option<GatewayAgentPeeringsPeeringExposeNatStateless>,
}

/// Use connection state tracking when performing NAT
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNatStateful {
    /// Time since the last packet after which flows are removed from the connection state table
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idleTimeout")]
    pub idle_timeout: Option<kube_core::duration::Duration>,
}

/// Use connection state tracking when performing NAT, use stateful NAT if omitted
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentPeeringsPeeringExposeNatStateless {
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentVpcs {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "internalID")]
    pub internal_id: Option<String>,
    /// Subnets is a map of all subnets in the VPC (incl. CIDRs, VNIs, etc) keyed by the subnet name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subnets: Option<BTreeMap<String, GatewayAgentVpcsSubnets>>,
    /// VNI is the VNI for the VPC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vni: Option<u32>,
}

/// Subnets is a map of all subnets in the VPC (incl. CIDRs, VNIs, etc) keyed by the subnet name
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentVpcsSubnets {
    /// CIDR is the subnet CIDR block, such as "10.0.0.0/24"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cidr: Option<String>,
}

/// GatewayAgentStatus defines the observed state of GatewayAgent.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatus {
    /// AgentVersion is the version of the gateway agent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "agentVersion")]
    pub agent_version: Option<String>,
    /// Generation of the last successful configuration application
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedGen")]
    pub last_applied_gen: Option<i64>,
    /// Time of the last successful configuration application
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedTime")]
    pub last_applied_time: Option<String>,
    /// Time of the last heartbeat from the agent
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastHeartbeat")]
    pub last_heartbeat: Option<String>,
    /// State represents collected data from the dataplane API that includes FRR as well
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<GatewayAgentStatusState>,
}

/// State represents collected data from the dataplane API that includes FRR as well
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusState {
    /// BGP is BGP status
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bgp: Option<GatewayAgentStatusStateBgp>,
    /// Dataplane is the status of the dataplane
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dataplane: Option<GatewayAgentStatusStateDataplane>,
    /// FRR is the status of the FRR daemon
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub frr: Option<GatewayAgentStatusStateFrr>,
    /// LastCollectedTime is the time of the last successful collection of data from the dataplane API
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastCollectedTime")]
    pub last_collected_time: Option<String>,
    /// Peerings is the status of the VPCs peerings where key is VPC1->VPC2 and data is for one direction only
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub peerings: Option<BTreeMap<String, GatewayAgentStatusStatePeerings>>,
    /// VPCs is the status of the VPCs where key is the vpc (vpcinfo) name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vpcs: Option<BTreeMap<String, GatewayAgentStatusStateVpcs>>,
}

/// BGP is BGP status
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgp {
    /// VRFs keyed by VRF name (e.g. "default", "vrfVvpc-1")
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vrfs: Option<BTreeMap<String, GatewayAgentStatusStateBgpVrfs>>,
}

/// VRFs keyed by VRF name (e.g. "default", "vrfVvpc-1")
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfs {
    /// Neighbors keyed by an ip address string
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub neighbors: Option<BTreeMap<String, GatewayAgentStatusStateBgpVrfsNeighbors>>,
}

/// Neighbors keyed by an ip address string
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighbors {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionsDropped")]
    pub connections_dropped: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "establishedTransitions")]
    pub established_transitions: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv4UnicastPrefixes")]
    pub ipv4_unicast_prefixes: Option<GatewayAgentStatusStateBgpVrfsNeighborsIpv4UnicastPrefixes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ipv6UnicastPrefixes")]
    pub ipv6_unicast_prefixes: Option<GatewayAgentStatusStateBgpVrfsNeighborsIpv6UnicastPrefixes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "l2VPNEVPNPrefixes")]
    pub l2_vpnevpn_prefixes: Option<GatewayAgentStatusStateBgpVrfsNeighborsL2VpnevpnPrefixes>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastResetReason")]
    pub last_reset_reason: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localAS")]
    pub local_as: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub messages: Option<GatewayAgentStatusStateBgpVrfsNeighborsMessages>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "peerAS")]
    pub peer_as: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remoteRouterID")]
    pub remote_router_id: Option<String>,
    /// BGPNeighborSessionState represents the BGP FSM state for a neighbor.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sessionState")]
    pub session_state: Option<GatewayAgentStatusStateBgpVrfsNeighborsSessionState>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsIpv4UnicastPrefixes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "receivedPrePolicy")]
    pub received_pre_policy: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sent: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsIpv6UnicastPrefixes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "receivedPrePolicy")]
    pub received_pre_policy: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sent: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsL2VpnevpnPrefixes {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "receivedPrePolicy")]
    pub received_pre_policy: Option<u32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sent: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsMessages {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub received: Option<GatewayAgentStatusStateBgpVrfsNeighborsMessagesReceived>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sent: Option<GatewayAgentStatusStateBgpVrfsNeighborsMessagesSent>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsMessagesReceived {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capability: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notification: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRefresh")]
    pub route_refresh: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub update: Option<u64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateBgpVrfsNeighborsMessagesSent {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub capability: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keepalive: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub notification: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub open: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeRefresh")]
    pub route_refresh: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub update: Option<u64>,
}

/// Neighbors keyed by an ip address string
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum GatewayAgentStatusStateBgpVrfsNeighborsSessionState {
    #[serde(rename = "unset")]
    Unset,
    #[serde(rename = "idle")]
    Idle,
    #[serde(rename = "connect")]
    Connect,
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "open")]
    Open,
    #[serde(rename = "established")]
    Established,
}

/// Dataplane is the status of the dataplane
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateDataplane {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// FRR is the status of the FRR daemon
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateFrr {
    /// LastAppliedGen is the generation of the last successful application of a configuration to the FRR
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastAppliedGen")]
    pub last_applied_gen: Option<i64>,
}

/// Peerings is the status of the VPCs peerings where key is VPC1->VPC2 and data is for one direction only
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStatePeerings {
    /// Bytes is the number of bytes sent on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub b: Option<u64>,
    /// BytesPerSecond is the number of bytes sent per second on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bps: Option<f64>,
    /// Drops is the number of packets dropped on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub d: Option<u64>,
    /// Packets is the number of packets sent on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub p: Option<u64>,
    /// PktsPerSecond is the number of packets sent per second on the peering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pps: Option<f64>,
}

/// VPCs is the status of the VPCs where key is the vpc (vpcinfo) name
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct GatewayAgentStatusStateVpcs {
    /// Bytes is the number of bytes sent on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub b: Option<u64>,
    /// Drops is the number of packets dropped on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub d: Option<u64>,
    /// Packets is the number of packets sent on the vpc
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub p: Option<u64>,
}

